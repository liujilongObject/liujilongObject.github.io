import{_ as a,c as i,o as s,a2 as t}from"./chunks/framework.Bk-UhgEh.js";const E=JSON.parse('{"title":"HTML元信息类标签","description":"","frontmatter":{},"headers":[],"relativePath":"HTML/元信息类标签.md","filePath":"HTML/元信息类标签.md"}'),e={name:"HTML/元信息类标签.md"},h=t('<h1 id="html元信息类标签" tabindex="-1">HTML元信息类标签 <a class="header-anchor" href="#html元信息类标签" aria-label="Permalink to &quot;HTML元信息类标签&quot;">​</a></h1><p>我们可以先来了解一下什么是元信息类标签。所谓元信息，是指描述自身的信息，元信息类标签，就是 HTML 用于描述文档自身的一类标签，它们通常出现在 head 标签中，一般都不会在页面被显示出来。</p><p>元信息多数情况下是给浏览器、搜索引擎等机器阅读的，有时候这些信息会在页面之外显示给用户，有时候则不会。</p><p>（<strong>引用Winter的解释,很合理</strong>）</p><p><strong>以下是几个常用的标签</strong></p><h3 id="head" tabindex="-1">head <a class="header-anchor" href="#head" aria-label="Permalink to &quot;head&quot;">​</a></h3><p>head 标签本身并不携带任何信息，它主要是作为盛放其它语义类标签的容器使用。</p><p>head 标签规定了自身必须是 html 标签中的第一个标签，它的内容必须包含一个 title。如果文档作为 iframe，或者有其他方式指定了文档标题时，可以允许不包含 title 标签。</p><h3 id="title" tabindex="-1">title <a class="header-anchor" href="#title" aria-label="Permalink to &quot;title&quot;">​</a></h3><p>title 标签表示文档的标题，应该是完整地概括整个网页内容的。</p><h3 id="meta" tabindex="-1">meta <a class="header-anchor" href="#meta" aria-label="Permalink to &quot;meta&quot;">​</a></h3><p>meta 标签是一组键值对，它是一种通用的元信息表示标签。</p><p>在 head 中可以出现多个 meta 标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 用于表示元信息的值。</p><p>基本写法</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">application-name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;lsForums&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="具有-charset-属性的-meta" tabindex="-1">具有 charset 属性的 meta <a class="header-anchor" href="#具有-charset-属性的-meta" aria-label="Permalink to &quot;具有 charset 属性的 meta&quot;">​</a></h4><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> charset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;UTF-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><em>从 HTML5 开始，为了简化写法，meta 标签新增了 charset 属性。添加了 charset 属性的 meta 标签无需再有 name 和 content。</em></p><p><strong>charset 型 meta 标签描述了 HTML 文档自身的编码形式。建议这个标签放在 head 的第一个，以防文档出现乱码</strong></p><h4 id="name-为-viewport-的-meta" tabindex="-1">name 为 viewport 的 meta <a class="header-anchor" href="#name-为-viewport-的-meta" aria-label="Permalink to &quot;name 为 viewport 的 meta&quot;">​</a></h4><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=500, initial-scale=1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这个meta类型没有在HTML中标准定义，但是是移动开发中的事实标准(就是行业内的一个约定俗成的写法)。他的content是一个复杂结构，值是用逗号分隔的键值对，格式是key=value。</p><p><strong>viewport能够控制的全部属性：</strong></p><ul><li>width：页面宽度，值可以是具体的数字，也可以是 device-width，表示跟设备宽度相等。</li><li>height：页面高度，值可以是具体的数字，也可以是 device-height，表示跟设备高度相等。</li><li>initial-scale：初始缩放比例。</li><li>minimum-scale：最小缩放比例。</li><li>maximum-scale：最大缩放比例。</li><li>user-scalable：是否允许用户缩放。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><em>上述的meta标签写法普遍用于做移动端适配: 禁止用户缩放，将宽度设为设备宽度。</em></p><h4 id="其他meta写法-一些常见的" tabindex="-1">其他meta写法(一些常见的) <a class="header-anchor" href="#其他meta写法-一些常见的" aria-label="Permalink to &quot;其他meta写法(一些常见的)&quot;">​</a></h4><ul><li>author: 页面作者。</li><li>description：页面描述，一般被用于搜索引擎。</li><li>keywords: 页面关键字，SEO 场景用的较多。</li><li>referrer: 跳转策略，是一种安全考量。</li></ul>',28),l=[h];function n(p,r,k,o,d,c){return s(),i("div",null,l)}const g=a(e,[["render",n]]);export{E as __pageData,g as default};
